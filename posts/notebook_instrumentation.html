<html lang="en">
  <head>
    <meta  charset="utf-8" name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Notebook Instrumentation</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
    <link href="../assets/shared.css" rel="stylesheet">
    <link href="../assets/posts.css" rel="stylesheet">
    <script src="helper.js"></script>
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/default.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
<body>
  <div class="container" id="content">
    <div class="row" style="margin-bottom: 50px;">
      <h1>Instrumenting the Notebook</h1>
      <h2 style="color:var(--blue-grey-400); margin-top: 0px">a Model Inspired by Interactive Visualizations</h2>
      <h3 style="float:right">A post by <a href="/">Yifan</a></h3>
    </div>

    
    <div class="row">
      <p>
        Programming notebooks are a popular medium for data analysis. In addition to code, rich text, and visualizations, notebooks can support interactions, such as <a href="https://github.com/jupyter-widgets/ipywidgets">ipywidgets</a>, or direct javascript integration in <a href="https://observablehq.com/">observables</a>. The rich range of functionalities supported by notebooks makes them an ideal target for tools that aid in data analysis, supporting code, visuals, and interactions.
        For instance, projects like <a href="https://medium.com/vis-gl/exploring-geospatial-data-with-kepler-gl-cf655839628f">kepler.gl</a>, <a href="https://github.com/vega/ipyvega">ipyvega</a>, and my research project, <a href="https://github.com/yifanwu/midas">Midas</a>, all have integrations to Jupyter Widget.
      </p>
      <p>
        This post will discuss a model for implementing custom interactive widgets to Python notebooks. The high-level concepts should generalize to other notebooks, such as Jupyter Lab, Colab, and <a href="https://www.deepnote.com/">deepnote</a>. By the end of the post, you should realize that we can do much beyond the ipywidgets provided. We can changing the UI beyond just the output area of the cell---we can, for instance, make a dashboard! We can update the UI based not just on UI event---we can, for instance, listen to events triggered by code execution.
      </p>
      <p>
        If you are not interested in implementation details, feel free to toggle the content: <a data-toggle="collapse" data-target=".collapse" style="font-weight: bold;">Toggle Details</a>.
      </p>
    </div>
    <div class="row">
      <h3>
        Communicating Between the Kernel and the UI
      </h3>
      <p> At the very basic, for any language kernel to communicate with the UI state, there needs to be a communication layer that sends events from the UI layer to the kernel and back. 
        The UI events can be code execution, keystrokes, or interaction with some UI components (anything that can be captured by the UI).
        Note that the exception is, of course, of Javascript kernels running on the main thread in the browser. If it is Javascript running in Node.js or a WebWorker thread, the discussion still applies.
      </p>
    </div>
    <div class="row collapse show">
      <p>
        Concretely, in Jupyter notebooks, this communication can be done in (at least) two ways. One is using a custom <a href="https://ipywidgets.readthedocs.io/en/latest/examples/Widget%20Custom.html">Jupyter Widget</a>, or using <a href="https://jupyter-notebook.readthedocs.io/en/stable/comms.html">Comms</a> (short for communication).
      </p>
      <p> The first method is well documented in the <a href="https://ipywidgets.readthedocs.io/en/latest/examples/Widget%20Custom.html">link</a>, and you can also refer to <a href="https://github.com/vega/ipyvega">ipyvega</a> for example. It is also the officially supported one.
        The second method, comms, is similar to all message-passing systems, like WebWorkers and the actor model. The UI sends the kernel some message, and the kernel handles that messages and sends messages back to the UI.
      </p>
      <p>To pick between the two approaches, the table below draws a comparison. The Comm approach is lower level, hence more flexible and easier to learn, but possibly more tedious to write. The design of Jupyter Widgets is probably very elegant, but also opinionated. If you are like me and would prefer not to learn another framework for thinking about state and control, pick <i>Comm</i> and build your UI, for which you can use React, Vue, jQuery etc.
      </p>
      <table class="table center" style="width: var(--size-14);">
        <thead>
          <tr>
            <td>Property</td>
            <td>Ipywidgets</td>
            <td>Comms</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Flexibility</td>
            <td>Low</td>
            <td>High</td>
          </tr>
          <tr>
            <td>Succinct</td>
            <td>High</td>
            <td>Low</td>
          </tr>
        </tbody>
      </table>
      <p>Since there is good documentation for the first approach, for the rest of this post, I'll talk in more detail about the code to set up for the second approach. For an example implementation of the first approach, see <a href="https://github.com/vega/ipyvega/blob/master/vega/widget.py">widget.py</a>. Now, let's begin with the UI side code on the frontend. The following is useful if you want to use <b>Python kernel to control UI events</b>.
      </p>
      
      <pre><code class="javascript" id="js_handler">Jupyter.notebook.kernel.comm_manager.register_target(YOUR_COMM_NAME, handler);
function handler (comm, msg) {
  // comm will be the reference to the communication layer
  function onMessage(msg) {
    // msg.content.data will contain your message
    const load = msg.content.data;
    // you can use this message to make changes to your UI state, for example, I have `.type` in my message to inform the handler what shape to expect the message as
    switch (load.type) {
      case "hide": {
        // invoke the component to change
        // for instance, refToAReactComponent here could be 
        refToAReactComponent.hide();
        return;
      }
      case "show": {
        refToAnotherReactComponent.addSelection(load.value);
        return;
      }
      // and so on...
 }
  // now set the handler
  comm.on_msg(onMessage);
}
      </code></pre>
      <p>This should be the only part of your frontend code that's different from what you would have otherwise written for a traditional interface. Like all other UIs, the UI that's part of Jupyter Notebooks is changing the state of the UI, e.g., new elements, different styling, based on new events. If you have an existing UI library, adding it to the notebook requires little change. For instance, calls like <code>refToAReactComponent.hide()</code> in the snippet above 
      </p>
      <p>
        Now, to go in the opposite direction, we need to set up handlers in Python, which will look something like the following:
      </p>
      <pre><code class="python" id="python_handler">from ipykernel.comm import Comm
self.comm = Comm(target_name = YOUR_COMM_NAME)
self.comm.on_msg(msg_handler)
self.comm.send(your_msg_obj)
def msg_handler(msg):
    # your object from JS will be in msg["content"]["data"]
    # you should write code that changes the python state here
      </code></pre>
      <p>
        ðŸŽ‰ With these two code snippets, you have set up the most important parts of your software! ðŸŽ‰
      </p>
    </div>
    <div class="row">
      <h3>UI Affordances of the Notebook</h3>
      <p>
        There are many ways to modify the UI of the notebook beyond creating a widget that fits the cell output area.
        The first is a <b>dashboard</b> instead of .
        Another is <b>cell manipulation</b>, where you can create and modify cells. 
      </p>
      <p>
        Below we give some concretae examplesa nd code snippets for these UI changes.
      </p>
      <div class="collapse show">
        <p> <b>Dashboard</b> If you work with JupyterLab, you can directly access special widgets like <code>MainAreaWidget</code> (example in <a href="https://jupyterlab.readthedocs.io/en/stable/developer/extension_tutorial.html#extension-tutorial">this tutorial</a>).
 
          When working Jupyter Notebooks, you have to get a little more creative. Consider the snippet below, which is how I instrumented a "dashboard" area to the right side of the notebook. In the snippet, I rely on the internal implementation of the Jupyter notebook, where <code>notebook</code> is the ID of the notebook div. It's, of course, not great that I'm relying on this, but for a research prototype, this hack-ish approach meets my needs.
        </p>
        <pre><code>const aDiv = $("&lt;div id="+yourID+"/&gt;");
$("#notebook").append(aDiv);
// then later you create the React component
ReactDOM.render(&lt;YouComponent/&gt;, document.getElementById("yourID"))</code></pre>
        <p>
          If you want an example of cell manipulation, a great example for complex cell manipulation in JupyterLab is <a href="https://github.com/microsoft/gather">Gather</a>. Concretely, for Jupyter notebooks, you can manipulate these like the following
        </p>
        <pre><code class="javascript">c = Jupyter.notebook.insert_cell_above("code");
          c.set_text("boo = 1");</code></pre>
      </div>
    </div>
    <div class="row">
      <h3>Gluing Everything Together</h3>
      <p>
        Lastly, we need to tell the notebook to be aware of the extension. Then the notebook can serve the Javascript files, which will run the set up to create the communication layer for your application.  This process is course different across platforms. In the next paragraph I discuss how to for Jupyter Notebook.
      </p>
      <div class="collapse show">
        <p>
          Specifically for Jupyter Notebook The <a href="https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/Distributing%20Jupyter%20Extensions%20as%20Python%20Packages.html">official doc</a> and example implementations like that in are both good references.
        </p>
      </div>
    </div>
    <div class="row">
      <h3>
        Picking a Platform
      </h3>
      <p>
        When choosing what platform to implement/extend your tools to, we should consider both the audience and the engineering requirements. For data scientists, the options would be either Jupyter Notebook or JupyterLab, given that the Jupyter ecosystem has the most number of existing users. To compare, JupyterLab, as a second-generation python notebook, is much more ambitious than Jupyter Notebooks. JupyterLab is feature-rich with an opinionated framework and set of accompanying APIs. The main framework, <a href="https://github.com/phosphorjs/phosphor">Phosphors</a>, is sophisticated and seems to be similar to mobile app frameworks and indirectly, React and the like. However, my issue trying out making a complex JupyterLab extension was that the documentation was very sparse, which requires reading a lot of source code and digging around other repositories (such as <a href="https://github.com/mkery/Verdant">Verdan</a> and <a href="https://github.com/microsoft/gather">Gather</a>). Working Jupyter, on the other hand, is a lot scrappier. It's great if you are already tied to a frontend stack (for me, Typescript w/ React), because you can do a simple initial "hack" and then use everything you have as is, and also make sure that you can share most of your code.
      </p>
    </div>
    <div class="row">
      <p>
        That's all I have for now. If you have comments or corrections, please let me know!
      </p>
    </div>
    <div style="margin-bottom:100px"></div>
</body>
</html>